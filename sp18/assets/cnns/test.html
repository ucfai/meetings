<!doctype html>
<html style="height: 100%" lang="en">
<head>
    <meta charset="UTF-8">
    <title>Easing Test</title>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <style src="matrix.css"></style>
    <script src="matrix.js"></script>
    <script src="../nns/vivus.js"></script>
    <style>
        svg text {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        pointer-events: none;
      }
    </style>
</head>
<body style="height: 100%" onclick="next();">

    <svg width="100%" height="100%" id="anim"></svg>
    <script>
    /*
    TODO:
    input matrix
    kernel
    output
    lines from cells in kernel matrix to input cells. reverse anim. circle shoots into a_(i,j) of output matrix 
    
    maybe make each matrix a g and put them both into an svg?
    use matrix() for all three matrices, then add svg to contain all of them
    
    line path= mat1_cell.coords to mat2_cell.coords
    
    
    
    */
        

    var y_step = 0, x_step = 0;
    var input_data = 
    {
        values:
        [
            [1, 2, 3, 4, 5],
            [2, 3, 4, 5, 1],
            [3, 4, 5, 1, 2],
            [4, 5, 1, 2, 3],
            [5, 1, 2, 3, 4]
        ]
    };

    var input_options = 
    {
        container: "#anim",
        show_labels : false,
        start_color : '#ffffff',
        end_color : '#3498db',
        width: 250,
        height: 250,
        margin: {top: 100, right: 50, bottom: 100, left: 50},
        highlight_cell_on_hover: true,
        highlight_cell_color: '#2ecc71'
    };

    input_matrix = Matrix(input_data,input_options); //input matrix
    console.log(input_matrix);
        
    var kernel_data =
    {
        values:
        [
            [0, 1, 0],
            [1, 1, 1],
            [0, 1, 0],

        ]
    };
    
    var kernel_options = 
    {
        paths: [{type: "OneToOne", matrix: input_matrix}/*,{type: "allToOne", matrix: feature_matrix}*/],
        container: "#anim",
        show_labels : false,
        start_color : '#ffffff',
        end_color : '#3498db',
        width: 150,
        height: 150,
        margin: {top: 200, right: 50, bottom: 100, left: 400},
        highlight_cell_on_hover: true,
        highlight_cell_color: '#2ecc71'
    };
        
    kernel_matrix = Matrix(kernel_data,kernel_options);
    
    var playit = [];
    var temp;     
        
    var pathClasses = [];//document.getElementsByClassName("f_0_0");
    //console.log(input_matrix[1].r - kernel_matrix[1].r + 1);
    for(var i = 0; i < input_matrix.r - kernel_matrix.r + 1; i++)
    {
        pathClasses[i] = [];
        playit[i] = [];
    for(var j = 0; j < input_matrix.c - kernel_matrix.c + 1; j++)
    {
        playit[i][j] = [];
        pathClasses[i][j] = document.getElementsByClassName("f_"+j+"_"+i);
        //console.log(pathClasses[i][j].length);
        for (var k = 0; k < pathClasses[i][j].length; k++)
        {
            temp = new Vivus(pathClasses[i][j][k], {duration: 50}, 
                            function(){if(this.getStatus() === 'end') this.play(-1);}).stop();
            playit[i][j].push(temp);
        }
    }
    }
    
    function next()
    {
        console.log(x_step +", "+ y_step);
        if(x_step < pathClasses[0].length)
        {
            for(var k = 0; k < pathClasses[0][0].length; k++)
            {
                playit[y_step][x_step][k].play(1);
            }
            x_step++;
            return;
        }
        else
        {
            x_step = 0;
            if(y_step+1 < pathClasses.length)
                y_step++;
            else
                y_step = 0;
            next();
        }
    };    
            
    </script>
</body>
</html>